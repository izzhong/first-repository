在这里记录我的想法

<gr_object_model.h>
	//接下来就是讨论这个约束器的问题了
	//约束器的功能其实就相当于一个函数 根据约束器制定的规则
	//修改给定物体的属性集 就这么简单
	//约束器在内存中其实就是一个个的类 在表层就是一个个的可调用对象
	//我们显然不希望这样像函数一样的东西存在多组备份
	//而我们也不希望在经过了一系列复杂的对象内存变化之后这个函数就没了
	//同时每个物体又有仅仅支持自己的约束发生器
	//也可能有约束发生器适用于几个物体
	//也有可能我们想要创建全局的发生器
	//但是这些发生器都应该保证他们的内存安全 
	//所以约束发生器在底层也使用智能指针
	//那么首先让我们来看第一个问题
	//如果创建约束发生器并绑定到一个物体上
	using ConstraintGeneratorTable =
		typename std::forward_list<std::shared_ptr<ConstraintGenerator>>;


<gr_constraint_pipeline.h>
		//其实 我好像根本不用设置这个表
		//我可以直接获得那个表 然后直接遍历 遍历的时候检测 是否可以约束就行了
		//如果我设置了这个表的话 就应该添加别的逻辑 加快遍历速度
		//因为有的物体不管怎样样它就是会遍历
		//有的物体仅仅有的时候会存在约束 而大部分时候都没有约束
		//有的物体永远都不会有约束
		//所以 怎么办 
		//使用类似约束器那样的方法 创建全局和局部约束
		//或者采用这样一种方案 在管线创建的时候 我们肯定之后那些物体需要约束 而那些物体不存在约束
		//所以约束表在第一次创建约束管线的时候就被填充 这样某些物体就会存在两份智能指针 这样的话 如果我们想要释放掉一份资源
		//就需要释放两次 一次是释放掉约束管线内的内存 一个是释放掉物理管线内的内存
		//如果我们想要将它的约束属性去掉  那么就仅仅需要释放掉约束管线内的内存
		//但是这与物体模型中是否支持约束的属性设置冲突 两者执行的功能形成了交叉
		//所以我们就有两种方案可选 
		//1.去掉这个属性  使用这种方案 
		//2.保留这个属性 那么就需要每次执行都遍历全局对象表用来生成局部约束表 而每次执行完毕之后都释放掉
		//这两种方案其实都不太好  但是第二种特别不好 因为约束不像碰撞 它一直都在发生 
		//控制着游戏的所有物体的所有运动模式  而且大部分物体都是带有约束的 所以我们直接遍历对象表查看是否支持约束
		//然后直接应用约束这种方案应该是最好的  
		//同时这种方案也要求我们必须为大部分物体模型创建自己的约束动作 这样才不会浪费资源 同时会加快速度
		//保存约束表
		//反正大概就是两种方案 第一种就是不保存这个东西 直接每次都遍历全局对象表
		//第二种方案就是保存这个东西  但是不是每次都修改它 由总的物理管线控制 在用户修改物体属性的时候增加或删除表
		//同时还要注意一些其他问题 比如用户想要销毁某一对象 那么这个表里如果有那个对象也要修改
		//同时 如果大部分对象都需要约束的话 这是大部分情况 我们相当于保存了另外一份资源的智能指针
		//不仅浪费资源 还会让问题变得更加复杂
		//所以 目前的方案是 不保存这个表
		//ObjectModelTable constraint_omt_;
		//我仅仅保存这个表的引用  在创建管线时绑定
		std::weak_ptr<ObjectModelTable> constraint_omt_;


//有关约束管线
约束器的出现本来是为了解决这样一个问题
有的时候很多不同类型的对象他们可以具有相同的约束形式
为了对他们提供约束 我们需要对每一个对象实现一个
相同的约束函数 这很不方便
所以才有了约束器的出现
但是约束器的使用有很大的问题
首先因为对象类型的不同
我们难以创建可以作用于所有对象的所有形式的约束器
因为约束器是独立于对象的
所以我们不能用动态的调用方式即虚函数的方式来调用
所以用约束器来实现对象的动作显得不现实 所以我创建了
动作发生器来实现对象的自定义动作

那么约束发生器的作用是怎样的呢？？
现在看来约束发生器的唯一用法就是创建引擎指定对象
的指定类型的约束器
比如质点重力约束器 
它仅仅可以绑定到继承自质点的对象 对对象的质点部分做出约束
如果我们想要对自定义对象进行约束 就需要继承约束发生器
并且自己编写约束 同时要求我们的对象必须继承自ObjectModel

这样就会出现一个问题
如果我们的约束器定义为这个样子
class ConstraintGenerator
{
public:
	virtual void operator()(ObjectModel* object) = 0;
}

这种定义有一个致命的错误
就是我在继承它的时候 其实我无法把它应用到其他的对象上

class LittleCatConstraintGenerator :
	public ConstraintGenerator
{
public:
	virtual void operator()(ObjectModel* object)
	{
		//无法将这个函数应用到LittleCat上
		//除非我们在LittleCat里定义一个这样的函数
		//而且必须是虚函数
		object->LittleCat::Fun();
	}
}

//为了实现这个约束管线
//我们必须继承一个约束发生器
//必须实现该约束发生器为调用一个继承自ObjectModel的虚函数
//我们必须在LittleCat里实现这个虚函数 同时基类也必须有这个函数
//否则将不能实现 这样我们就无法为对象提供多种约束
//因为我们不可能在一开始就知道对象需要多少约束
//而且 如果我们已经在类内实现了约束
//那么抛弃约束发生器管线也可以实现相同的功能

//所以这种方式其实没有用

//如果发生器其实是一个模板

template<typename ObjectModel>
class ConstraintGenerator
{
public:
	virtual void operator()(ObjectModel& object) = 0;
}

//如果约束器是这个形式
//我们想要使用约束器就必须这样写
//我们需要为每一种ObjectModel编写相应的约束器
class ParticleConstraintGenerator :
	public ConstraintGenerator<Particle>
{};
//然后继承此ParticleConsraintGenerator实现各种粒子约束
class ParticleConstraint :
	public ParticleConstraintGenerator
{
public:
	virtual void operator()(Particle& particle) override
	{
		//在此修改粒子的属性
		auto& attr = particle.GetAttribute();
		attr.position++;
	}
}
//然后我们为刚体定义一些约束
class RidigBodyConstraintGenerator :
	public ConstraintGenerator<RidigBody>
{};

class RigidBodyConstraint :
	public RigidBodyConstraintGenerator
{
public:
	virtual void operator()(RidigBody& ridigbody) override
	{
		auto& attr = ridigbody.GetAttribute();
		attr.position++;
	}
}

//假如我们定义了一个自定义的对象
class LittleCat :
	public RidigBody
	{}

我们想要为我们的小猫咪添加重力约束
因为对应到刚体有相应的刚体重力约束器 所以我们希望
刚体重力约束器可以直接添加到约束管线中
如果是这样约束管线应该如何实现呢
我们可以直接向约束发生器传递派生类对象
因为约束器作用到派生类的基类部分 如果我们仅仅
想要实现对基类部分数据的控制可以直接使用
如果我们想要对新定义的类型实现一些约束 就需要
实现约束器 对 要的就是这种效果 该怎么实现呢 ？？
首先约束器必须是一个继承树 否则无法天骄到容器里

假设此时管线存在三个互相没有继承关系的类
Particle RigidBody Light
他们都继承自ObjectModel
假设对应着每一个类型 都有多种对应类型的约束器
他们分别继承自对应类型的约束器接口
该约束器接口继承自一个约束器模板

我们的约束管线应该如何处理??

//虽然所有的约束器都继承自同一个类
//但是由于该类是模板类
//所以实际上我们无法把他们放到一个容器里
//这就导致了约束管线无法高效管理
//也就没有实现价值
class ConstraintPipeline
{
	
}


目前看来也许我应该放弃约束管线
采取相应的替代方案
将约束实现在各个ObjectModel中并作为虚函数
这样继承自每个类的对象就可以使用该约束
这样需要用户手动选择是否调用约束 并实现自己的约束动作
这种方法与约束管线相比最大的缺点就是难以实现全局约束
如果约束管线放弃管理局部约束 
仅仅实现全局约束
那么全局约束就必须能够作用到所有类型上
也就表示全局约束器必须可以绑定到同一个基类上
也就是说我们的管线的所有类型必须都继承自某一类型
这种要求太过苛刻 所以此时的全局约束的意义也就不大了

对于约束管线的实现以及是否要实现以后再议
目前仍然没有找到合理的实现方式


action -- 另外一个问题
动作是另外一个问题
这虽然看似不属于物理引擎的范围 
但是它是游戏对象的重要部分
对象的所有动作应该在此定义并与某一对象绑定
他的行为是显而易见的 创建一个动作类
将其绑定到某一类型的对象上 
其实一个对象就必须定义此对象的动作类
只不过动作类大部分都是函数
所以对象可以保存该动作类的指针从而在创建大量对象
的时候不需要创建大量的动作类
同时 动作的触发需要条件
该条件应该由对象本身控制
所以一个标准的动作类就只是一组动作函数
而对象类可以根据一些条件来选择的调用动作函数


tips:
我发现实现通用的管线太复杂了
针对单一游戏实现特定的对象组织方式显得非常简单
依靠此思路实现对应的对象 动作 约束 碰撞 更新 等
虽然基本上游戏都可以由这几部分组成
但是创建一个合理的管线包含这所有几种模式显得非常复杂

所以我还是采取另外一种思路
尽可能提供底层的实现选择
而放弃对高层建筑的建模 
即实现底层 高层应用方式不予实现
在积累了足够经验后再将其实现